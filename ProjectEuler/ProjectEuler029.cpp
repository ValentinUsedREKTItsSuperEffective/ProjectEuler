#include <iostream>
#include <map>
#include "PEUtility.hpp"

using namespace std;

/*
Consider all integer combinations of a^b for a = [2, 5] and b = [2, 5]:

            2^2=4,      2^3=8,      2^4=16,     2^5=32
            3^2=9,      3^3=27,     3^4=81,     3^5=243
            4^2=16,     4^3=64,     4^4=256,    4^5=1024
            5^2=25,     5^3=125,    5^4=625,    5^5=3125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

                        4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for a = [2, 100] and b = [2, 100]?

Answer:
*/

/*
By observing combinations, we can see few things.
For a = 2, every combination is unique so there is 100 - 2 + 1 = 99 distinct terms. (1)
It is the same with a = 3, a = 5 and every number that aren't the power of another a like 4 or 9.

For a = 4, it is a bit different because we saw that 4 could be obtain with {a = 2, b = 2}.
Thus, some combination results were already obtained when a = 2.

a = 2:  4       8       16      32      64      128     256     512     1024        ...
a = 4:  16      64      256     1024    ...

16, 64, 256, 1024 were already obtained. And every two steps in a = 2 will be found again when a = 4.
4 = 2^2, 16 = 4^2 = 2^(2*2) = 2^4, 64 = 4^3 = 2^(2*3) = 2^6, 256 = 4^4 = 2^(2*4) = 2^8, ..., 4^n = 2^(2*n)

Since the maximum b here is 100, 2^100 = 2^(2*50) = 4^50.
Thus, when a = 4, all combination until b = 50 were already computed.
But, for b = [51, 100], every combination will be distinct, so we have 100 - 51 + 1 new distinct value.

The same thing can be observe again when for a = 9 because 9 = 3^2, for a = 16 because 16 = 4^2, ...

In fact, when b is even, we can simplify a^b :

    a^b = a^([1/2] * 2b) = a'^2b

a^1/2 being the square root or a.

This show that when b < 51, all combination of a^b are duplicated from a'.
So only the combination when b = [51, 100] are new distinct values.
So when a is the square of a previous a, we can get 50 new distinct values. (2)

We can extend this idea to all form of a^b :
    a^b = a^([1/n] * nb) = a'^nb
eliminating combinations when b <= 100 / n because they are duplicated from a^1/n. (3)

But this only is not enough because things get tricky when a is the power > 2 of a previous a.

Starting with cubic a like 8 and 27. We have :

    8^1/3 = 2 and 8^2/3 = 4
    27^1/3 = 3 and 27^2/3 = 9

We know from (3) that for b = [2, 33] combinations are duplicated, respectively when a = 2 and a = 3.
We could think that there are only 32 duplicated value but 8^34 = 4^51, 8^36 = 4^54, ...
Same with 27 : 27^34 = 9^51, 27^36 = 9^54, ...

And in general, for a being the cubic of a previous a, we have :
    a^b = a^([2/3] * 3b/2) = a'^3b/2

Meaning that for b > (3), every b % 2 until 3b/2 <= 100 were duplicated for a^2/3.
So when b = {34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66}, a^b is already duplicated
making cubic value of previous a adding (1) - 32 - 17 = 50 new distinct values. (4)

The same analysis can be made for each after a^b like if a = a'^b
    a^b = a^([m/n] * nb/m) = a'^nb/m
with m = [1, n-1], then a^b is duplicated in a'^m/n when b % m = 0. (5)

Using (3) and (5), we can then determined duplicated value for when :
    a = 2^4 = 16    -> 49 from (3) and 16 from (5) for a total of 34 new distinct values
    a = 2^5 = 32    -> 19 from (3) and 10 [5*b/2] + 11 [5*b/3] + 8 [5*b/4] from (5) for a total of 51 new distinct values
    a = 2^6 = 64    -> 49 from (3) and 8 [6*b/4] + 5 [6*b/5] from (5) for a total of 37 new distinct values
    a = 3^4 = 81    -> 49 from (3) and 16 from (5) for a total of 34 new distinct values
*/

/*
    cf. https://www.mathblog.dk/project-euler-29-distinct-terms-sequence-ab/
*/

void _ProjectEuler029(){
    map<unsigned int, unsigned int> distincts;

    unsigned int sum = 0;
    unsigned int combination = 0;

    unsigned int minimumA = 2;
    unsigned int maximumA = 100;

    unsigned int minimumB = 2;
    unsigned int maximumB = 100;

    for(unsigned int a = minimumA; a <= maximumA; a++){
        if(distincts[a] == 0){
            sum += maximumB - minimumB + 1; // (1)

            combination = a * a;
            unsigned int b = 2;
            while(combination <= maximumB){
                cout << "distinct[" << combination << "] = " << b << endl;
                distincts[combination] = b++;
                combination *= a;
            }
        } else {
            if(distincts[a] == 2){
                sum += 50;
            } else if(distincts[a] == 3){
                sum += 50;
            } else if(distincts[a] == 4){
                sum += 34;
            } else if(distincts[a] == 5){
                sum += 51;
            } else if(distincts[a] == 6){
                sum += 37;
            }
        }
    }

    cout << sum << endl;
}

float convertB(float m, float n, float b){
    return b * n / m;
}

void ProjectEuler029(){
    unsigned int minimumA = 2;
    unsigned int maximumA = 100;

    unsigned int minimumB = 2;
    unsigned int maximumB = 100;

    bool combinations[maximumA+1][maximumB+1];

    for(unsigned int i = 0; i <= maximumA; i++){
        for(unsigned int j = 0; j <= maximumB; j++){
            combinations[i][j] = !(i <= 1 || j <= 1);
        }
    }

    unsigned int sum = (maximumA + 1 - minimumA) * (maximumB + 1 - minimumB); // +1 because maximum are included

    map<unsigned int, unsigned int> distincts;

    for(unsigned int a = minimumA; a <= maximumA; a++){
        if(distincts[a] == 0){
            unsigned int ab = a * a;
            unsigned int b = 2;
            while(ab <= maximumB){
                distincts[ab] = b++;
                ab *= a;
            }
        } else {
            for(unsigned int i = 1; i < distincts[a]; i++){
                for(unsigned int b = 2; distincts[a] * b / i <= maximumB; b++){
                    if(distincts[a] % 2 == 0){
                        if(distincts[a] / i > 2){
                            break; // get to the next i
                        }

                        if(distincts[a] / i < 2 && !(PEUtility::isNatural(convertB(i, distincts[a], b)))){
                            continue;
                        }
                    } else {
                        if(!(PEUtility::isNatural(convertB(i, distincts[a], b)))){
                            continue;
                        }
                    }

                    if(combinations[a][b]){
                        sum--;
                    }

                    combinations[a][b] = false;
                }
            }
        }
    }

    cout << sum << endl;
}
