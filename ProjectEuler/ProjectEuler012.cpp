#include <iostream>
#include <set>
#include <map>

using namespace std;

/*
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

                                                                    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

Answer: 76576500
*/

/*
Constraints
T = [1, 10]
N = [1, 1000]
*/

/*
     1: 1                                   = 1
     3: 1,3                                 = 1 + 2
     6: 1,2,3,6                             = 1 + 2 + 3
    10: 1,2,5,10                            = 1 + 2 + 3 + 4
    15: 1,3,5,15                            = 1 + 2 + 3 + 4 + 5
    21: 1,3,7,21                            = 1 + 2 + 3 + 4 + 5 + 6
    28: 1,2,4,7,14,28       =>  2^2 * 7     = 1 + 2 + 3 + 4 + 5 + 6 + 7
    36: 1,2,3,4,9,12,18,36  =>  2^2 * 3^2   = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8
    45: 1,3,5,9,15,45       =>  3^2 * 5     = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9
    55: 1,5,11,55           =>  5 * 11      = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
    66: 1,2,3,6,11,22,33,66 =>  2 * 3 * 11   = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11
*/

// SEE ALSO : https://en.wikipedia.org/wiki/Triangular_number

void ProjectEuler012_Naive(){
    int T = 10;
    int N[] = {1,2,3,4,5,6,7,8,9,10};

    set<unsigned int> divisors;

    for(int i = 0; i < T; i++){
        int n = N[i];

        if(n == 1){
            // Except for 1 any other number as at least 2 divisors : 1 and themselves
            cout << "Answer : 3" << endl;
        } else {
            unsigned int sum = 0;
            unsigned int i = 2;
            divisors.clear();
            while(divisors.size() + 2 <= n){
                // the sum natural number is n(n + 1)/2
                sum = i * (i + 1) / 2;

                divisors.clear();

                unsigned int minDiv = 2;
                while(minDiv * minDiv < sum){
                    if(sum % minDiv == 0){
                        divisors.emplace(minDiv);
                        divisors.emplace(sum/minDiv);
                    }

                    minDiv++;
                }

                i++;
            }

            cout << "Answer : " << sum << endl;
        }
    }

    return;
}

// Based on : https://en.wikipedia.org/wiki/Divisor_function#Properties
// if sum has prime divisor such as sum = a^x * b^y * ... * c^z then the number of divisors is (x+1)(y+1)(...)(z+1)
void ProjectEuler012(){
    int T = 10;
    int N[] = {1,2,3,4,5,6,7,8,9,10};

    map<unsigned int, unsigned int> primeExponents;

    for(int i = 0; i < T; i++){
        int n = N[i];

        if(n == 1){
            // Except for 1 any other number as at least 2 divisors : 1 and themselves
            cout << "Answer : 3" << endl;
        } else {
            unsigned int sum, sumBis;
            unsigned int i = 2;
            unsigned int divNumber = 2;
            primeExponents.clear();
            while(divNumber <= n){
                sum = sumBis = i * (i + 1) / 2;

                while(sumBis % 2 == 0){
                    sumBis /= 2;
                    primeExponents[2]++;
                }

                unsigned int prime = 3;
                while(prime * prime <= sumBis){
                    while(sumBis % prime == 0){
                        sumBis /= prime;
                        primeExponents[prime]++;
                    }

                    prime += 2;
                }

                if(sumBis > 1){
                    // Add this condition to avoid adding the key 1 in the map which would result in doubling the number divisors
                    primeExponents[sumBis]++;
                }

                divNumber = 1;
                for(auto p : primeExponents){
                    divNumber *= (p.second + 1);
                }

                primeExponents.clear();

                i++;
            }

            cout << "Answer : " << sum << endl;
        }
    }
}

